apply plugin: 'groovy'
apply plugin: 'cpp'

allprojects {
    apply plugin: 'java'
    apply plugin: 'idea'
    apply plugin: 'maven'

    repositories {
        mavenCentral()
        maven { url "http://repo.gradle.org/gradle/libs-releases-local" }
    }

    dependencies {
        testCompile 'org.spockframework:spock-core:0.6-groovy-1.8'
    }

    group = 'net.rubygrapefruit'
    version = '0.3-rc-2'

    sourceCompatibility = 1.5
    targetCompatibility = 1.5

    tasks.withType(Upload) {
        repositories {
            mavenDeployer {
                if (project.hasProperty('release')) {
                    repository(url: uri("https://gradle.artifactoryonline.com/gradle/libs-releases-local")) {
                        authentication(userName: artifactoryUserName, password: artifactoryPassword)
                    }
                } else {
                    repository(url: uri("$rootProject.buildDir/repo"))
                }
            }
        }
    }
}

dependencies {
    testCompile 'org.codehaus.groovy:groovy:1.8.7'
}

def nativeHeadersDir = file("$buildDir/nativeHeaders")

task nativeHeaders {
    def outputFile = file("$nativeHeadersDir/native.h")
    inputs.files sourceSets.main.output
    outputs.file outputFile
    doLast {
        outputFile.parentFile.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-o', outputFile
            args '-classpath', sourceSets.main.output.classesDir
            args 'net.rubygrapefruit.platform.internal.jni.NativeLibraryFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixFileFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixFileSystemFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixProcessFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.PosixTerminalFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.TerminfoFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.WindowsConsoleFunctions'
            args 'net.rubygrapefruit.platform.internal.jni.WindowsHandleFunctions'
        }
    }
}

cpp {
    sourceSets {
        main {
            source.exclude 'curses.cpp'
        }
        curses {
            source.srcDirs = ['src/main/cpp']
            source.include 'curses.cpp'
            source.include 'generic.cpp'
            source.include 'generic_posix.cpp'
        }
    }
}

def variants = [:]

libraries {
    if (org.gradle.internal.os.OperatingSystem.current().macOsX) {
        all {
            spec {
                includes(files('/System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/'))
                args("-arch", "x86_64", "-arch", "i386")
            }
        }
        universal {
            sourceSets << cpp.sourceSets.main
            spec {
                baseName = 'native-platform-osx-universal'
                args("-o", outputFile)
            }
        }
        cursesUniversal {
            sourceSets << cpp.sourceSets.curses
            spec {
                baseName = 'native-platform-curses-osx-universal'
                args("-lcurses")
                args("-o", outputFile)
            }
        }
        variants['osx-universal'] = [universal, cursesUniversal]
    } else if (org.gradle.internal.os.OperatingSystem.current().windows) {
        all {
            spec {
                includes(files("${org.gradle.internal.jvm.Jvm.current().javaHome}/include"))
                includes(files("${org.gradle.internal.jvm.Jvm.current().javaHome}/include/win32"))
                args("/DWIN32")
            }
        }

        def out = new ByteArrayOutputStream()
        exec {
            commandLine "cl.exe", "/?"
            errorOutput = out
            standardOutput = new ByteArrayOutputStream()
        }
        def header = out.toString().readLines().head()
        if (header.endsWith("for 80x86") || header.endsWith("for x86")) {
            i386 {
                sourceSets << cpp.sourceSets.main
                spec {
                    baseName = 'native-platform-windows-i386'
                }
            }
            variants['windows-i386'] = [i386]
        } else if (header.endsWith("for x64")) {
            amd64 {
                sourceSets << cpp.sourceSets.main
                spec {
                    baseName = 'native-platform-windows-amd64'
                }
            }
            variants['windows-amd64'] = [amd64]
        } else {
            throw new RuntimeException("Cannot determine compiler's target architecture")
        }

    } else if (org.gradle.internal.os.OperatingSystem.current().linux) {
        all {
            spec {
                includes(files("${org.gradle.internal.jvm.Jvm.current().javaHome}/include"))
                includes(files("${org.gradle.internal.jvm.Jvm.current().javaHome}/include/linux"))
            }
        }
        if (System.getProperty('os.arch') == 'i386' || project.hasProperty('multiarch')) {
            i386 {
                sourceSets << cpp.sourceSets.main
                spec {
                    baseName = 'native-platform-linux-i386'
                    args("-m32")
                }
            }
            cursesI386 {
                sourceSets << cpp.sourceSets.curses
                spec {
                    baseName = 'native-platform-curses-linux-i386'
                    args("-m32", "-lcurses")
                }
            }
            variants['linux-i386'] = [i386, cursesI386]
        }
        if (System.getProperty('os.arch') == 'amd64' || project.hasProperty('multiarch')) {
            amd64 {
                sourceSets << cpp.sourceSets.main
                spec {
                    baseName = 'native-platform-linux-amd64'
                    args("-m64")
                }
            }
            cursesAmd64 {
                sourceSets << cpp.sourceSets.curses
                spec {
                    baseName = 'native-platform-curses-linux-amd64'
                    args("-m64", "-lcurses")
                }
            }
            variants['linux-amd64'] = [amd64, cursesAmd64]
        }
    } else {
        baseName = "native-platform-solaris"
        main {
            sourceSets << cpp.sourceSets.main
            sourceSets << cpp.sourceSets.curses
            spec {
                includes(files("${org.gradle.internal.jvm.Jvm.current().javaHome}/include"))
                includes(files("${org.gradle.internal.jvm.Jvm.current().javaHome}/include/solaris"))
                args("-DSOLARIS", "-lcurses")
            }
        }
        variants['solaris'] = [main]
    }
    all {
        spec {
            includes(files(nativeHeadersDir, 'src/main/headers'))
        }
        def task = tasks["compile${spec.binary.name.capitalize()}"]
        task.dependsOn nativeHeaders
        test.dependsOn spec
    }
}

configurations {
    jni
}

def deployer = uploadJni.repositories.mavenDeployer

variants.each { variant, libs ->
    def variantName = GUtil.toCamelCase(variant)
    def nativeJar = task("nativeJar${variantName}", type: Jar) {
        from libs.collect { tasks["compile${it.name.capitalize()}"] }
        baseName = "native-platform-$variant"
    }
    artifacts {
        jni nativeJar
        runtime nativeJar
    }
    def jniPom = deployer.addFilter(variant) { artifact, file ->
        return file == nativeJar.archivePath
    }
    jniPom.groupId = project.group
    jniPom.artifactId = nativeJar.baseName
    jniPom.version = project.version
    jniPom.scopeMappings.mappings.clear()
}

javadoc {
    exclude '**/internal/**'
}

task sourceZip(type: Zip) {
    from sourceSets.main.allSource
    classifier = 'sources'
    extension = 'jar'
}

task javadocZip(type: Zip) {
    from javadoc
    classifier = 'javadoc'
    extension = 'jar'
}

artifacts {
    archives sourceZip
    archives javadocZip
}

def mainPom = uploadArchives.repositories.mavenDeployer.pom
mainPom.groupId = project.group
mainPom.artifactId = jar.baseName
mainPom.version = project.version
mainPom.scopeMappings.mappings.clear()
mainPom.withXml { provider ->
    def node = provider.asNode()
    def deps = node.appendNode('dependencies')
    ['osx-universal', 'linux-amd64', 'linux-i386', 'windows-amd64', 'windows-i386'].each { platform ->
        def dep = deps.appendNode('dependency')
        dep.appendNode('groupId', project.group)
        dep.appendNode('artifactId', "native-platform-${platform}")
        dep.appendNode('version', project.version)
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = "1.3-20120907220018+0000"
}
